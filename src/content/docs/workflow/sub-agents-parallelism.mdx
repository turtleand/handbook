---
title: Sub-Agents for Parallelism
description: Spawn background tasks to keep the main loop responsive. The >30s rule.
---

# Sub-Agents for Parallelism

**The rule:** Any task expected to take more than 30 seconds gets spawned as a sub-agent. No exceptions.

This keeps your main AI agent responsive while long-running work happens in the background.

## Why This Matters

When you're chatting with an AI agent, every command you send blocks the main loop until it completes. If that command takes 5 minutes (running tests, building a project, generating a report), you're frozen. You can't ask follow-up questions. You can't pivot. You're waiting.

**Sub-agents solve this.** Spawn the long task in the background. The main agent stays free for your next instruction. The sub-agent reports back when done.

## The 30-Second Rule

If a task **might** take longer than 30 seconds, spawn it.

**Examples that should spawn:**
- Running test suites
- Installing dependencies (`npm install`, `pip install`)
- Building projects (`npm run build`)
- Multi-file edits or refactoring
- Fetching data from 10+ websites
- Generating long reports or articles
- Git operations (commit, push, create PR)
- Anything with polling loops

**Examples that can run inline:**
- Reading files
- Single edits
- Quick lookups
- Memory updates
- Simple calculations

**When uncertain:** Spawn. The cost of an unnecessary sub-agent is low (a bit of overhead). The cost of freezing the main loop is high (you think the bot is dead).

## How It Works

### From the User's Perspective

**Without sub-agents:**
- You: "Run the test suite and create a PR."
- [5 minutes of silence]
- AI: "Tests passed. PR created."
- You: (wondering if the bot crashed)

**With sub-agents:**
- You: "Run the test suite and create a PR."
- AI: "Spawned sub-agent for testing and PR creation. I'll notify you when it's done. What's next?"
- You: "Also, draft a blog post about this feature."
- AI: "On it."
- [2 minutes later]
- AI: "Sub-agent finished. Tests passed, PR #47 created. Blog draft ready for review."

**The difference:** You stay in flow. You're not blocked waiting.

### From the AI's Perspective

When an agent spawns a sub-agent:
1. Creates a new session with a focused task
2. Passes context (what to do, where to report back)
3. Continues with the next user request
4. Gets notified automatically when the sub-agent finishes

**Push-based, not pull-based.** You don't poll for status. The sub-agent announces completion.

## Common Violations (Anti-Patterns)

These are mistakes we've made and learned from:

❌ **Running Playwright tests inline** (2+ minute freeze)  
✅ **Spawn sub-agent for tests**

❌ **Running `npm install` in main loop** (1-3 minute freeze)  
✅ **Spawn sub-agent for installation**

❌ **Sequential web fetches across 8 sites inline** (1+ minute freeze)  
✅ **Spawn sub-agent for batch fetching**

❌ **Any `exec` command with timeout > 30s inline**  
✅ **Spawn it**

❌ **Chaining 5 dependent tasks that total > 30s**  
✅ **Spawn a sub-agent to handle the sequence**

## The Cost Analysis

**Cost of freezing the main loop:**
- User thinks the bot is broken
- User can't issue new commands
- Context switch: User gets distracted, loses flow
- Trust erodes ("Why is this so slow?")

**Cost of spawning a sub-agent:**
- Slight overhead (fraction of a second)
- Slightly more token usage (separate session)
- Tiny operational complexity

**The math:** An unnecessary sub-agent costs nearly nothing. A frozen main loop costs flow, trust, and productivity.

**Bias toward spawning.**

## Multi-Tasking Example

You can have multiple sub-agents running at once:

- Sub-agent 1: Running test suite
- Sub-agent 2: Fetching data from API
- Sub-agent 3: Generating report
- Main agent: Answering your questions, taking new requests

When each finishes, it reports back. You get results as they complete, not sequentially.

## When NOT to Use Sub-Agents

**Don't spawn for:**
- Tasks under 10 seconds (overhead not worth it)
- Tasks where you need immediate feedback to proceed
- Interactive workflows (user needs to see each step)

**Gray area (10-30 seconds):**
- If it's part of an interactive flow: Keep inline
- If it's background work: Spawn

## Implementation Pattern

**Good sub-agent spawn:**
```
Task: "Build the site, run tests, and create a PR"
→ Spawn sub-agent with clear scope: "build-test-pr"
→ Sub-agent does all three steps
→ Reports back: "Build succeeded, tests passed, PR #47 created"
```

**Bad sub-agent spawn:**
```
Task: "Build the site, run tests, and create a PR"
→ Spawn sub-agent for build
→ Wait for build
→ Spawn sub-agent for tests
→ Wait for tests
→ Spawn sub-agent for PR
→ Wait for PR
(This is just slow sequential work with extra overhead)
```

**The principle:** Group related work into one sub-agent when possible.

## The User Experience Win

When this works well, interacting with AI feels **snappy**. You give an instruction. The agent acknowledges immediately. Work happens in the background. Results arrive when ready.

**You stay in flow.** That's the whole point.

---

**See also:**
- [Cost of Freezing > Cost of Spawning](/economics/cost-of-freezing)
- [Batch Similar Tasks](/economics/batch-similar-tasks)
